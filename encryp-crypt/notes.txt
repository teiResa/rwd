
Intro to Encryption and Cryptography
started: 2022-09-09
source: Futurelearn

To be moved to the notebooks when i remember where it is. I made an html one, and a js one, and a ux one... but i am too lazy to look for it.


~~~~~~~~~

Week 1
In this first week, you will:

Discover the definition of encryption and the key parts of the encryption process
Learn about some of the historical uses of encryption
Explore the Caesar cipher and see how it can be broken easily
Learn how to encrypt a message using a more complex cipher, the Vigenère cipher, and discover why it is more secure than a Caesar cipher
Discover how the security of encryption systems is measured

```````
What is encryption?
- process that transforms data to obscure its meaning
- PLAINTEXT --> CIPHERTEXT

~~~~~~~~~~
~~The encryption algorithm
~~
~~ plaintext + key = ciphertext
~~
~~~~~~~~~~

- ENCRYPTION ALGORITHM is the set of instructions that you must follow to modify the plaintext so that it becomes encrypted. This is often referred to as a cipher.
- As well as the plaintext, the encryption algorithm takes another input: a key.

- KEY determines the output of the encryption algorithm; different keys will produce different ciphertexts. This component allows you to restrict access to the message, as only those who know the key can decrypt the message.
-Keys can take many forms. In modern-day encryption, keys are most often very long strings of numbers and letters, which are generated by an algorithm. The process of creating a key — whether by hand or through an algorithm — is called KEY GENERATION.

~~~~~~~~~~
~~The decryption algorithm
~~
~~ ciphertext - key = plaintext **
~~
**kinda.
~~~~~~~~~~

DECRYPTION ALGORITHM takes the ciphertext and the key as its inputs, and returns the plaintext. This algorithm might simply be the reverse of the set of instructions that were followed to encrypt the plaintext, or a completely different algorithm entirely.

The algorithms should be designed so that the decryption algorithm always turns the encrypted form of a message back into the original message. If you make a mistake when following the encryption algorithm, the person decrypting the ciphertext will not be able to determine the plaintext.

If you have designed a strong encryption scheme, you should be able to let everyone know the encryption and decryption algorithms without making it easier for your enemies to hack your system. As long as the key used to encrypt a message is kept secret, only the people who know the key should be able to decrypt the message correctly.


A summary of encryption
Encryption is the process of transforming data to obscure its meaning. To do this, you need to use an encryption scheme (a cipher), which will consist of:

An encryption algorithm
A decryption algorithm
And a key generation technique
The encryption algorithm takes your plaintext and a key as inputs and will output a ciphertext.

The decryption algorithm takes the key and ciphertext as inputs and will output a plaintext.

The specific key used should be kept secret so that only the intended recipients can open the message.


















1.10
True randomness can be achieved only if the computer can take a measurement from some external physical phenomenon and use it as part of its generator algorithm. For example, a sensor could be used to measure the nuclear decay of an atom or the random movements inside a lava lamp. These values are called nondeterministic in that they cannot be predicted.

Stream ciphers
A stream cipher is one where the plaintext is encrypted one bit at a time. Plaintext bits are combined with a pseudorandom stream of bits called a keystream. Typically, the combining operation is the XOR operation that you learned about in the previous step.

The keystream is generated from a random seed value and this seed value is the cryptographic key that the receiving device needs to recreate the keystream and decrypt the ciphertext. The length of the seed value is typically 128 bits.

The keystream can be recreated if someone gets hold of the seed value, so stream ciphers are not perfectly secure. However, stream ciphers are widely used and they are very useful where the length of the plaintext is not known in advance, such as in wireless communication systems.

Block ciphers
In a block cipher, the message is broken into blocks containing multiple bits that are then encrypted. If the block length is longer than the message that needs to be encrypted, the message is padded with random content to make it longer.

Block ciphers can help to obscure the length of your message because each block is uniform in length. This means that an attacker can see how many blocks your message is encrypted into, but not the exact length of the message. However, they require more memory to use and are slower to implement than a stream cipher.

Because block ciphers encrypt data in blocks, you can add additional information to a message to indicate whether it has been decrypted properly. This allows the receiver to verify the authenticity of the message, which is something that they cannot do with a stream cipher.

Implementations of the block cipher are based on a protocol called the Feistel cipher. You can read more about the Feistel cipher here.